=== The Domain Model

Before we can program the event registration app, we need to model it.

For this, use the free modelling program link:https://cruise.umple.org/umpleonline/[Umple]. Full documentation on how to use Umple can be found link:https://cruise.umple.org/umple/GettingStarted.html[here].

Ensure that Umple is configured as shown in the image below:

image::UmpleConfig.png[]

Readily obvious is the need for a class to hold information about people and events. As people register for events, these two classes will need to be associated.

Naively we may want to come up with a domain model that looks something like the image below: 

image::NaiveUML1.PNG[align="center"]

There are numerous problems with this scheme. Some are listed below in order of severity:

1. There is no constraint on this association. In best practice, we avoid unconstrained associations for security and cohesive behaviour reasons. To ensure our application code can only be used in the intended fashion, we must constrain all relationships between entities. In this case, there is no practical reason for events (E) and person (P) to be aware of each other. One needs to be independent.
2. We can have arbitrarily many events or people registering for events. Even when the association is constrained to a single direction, person or events will have to hold an array of events or persons respectively. Storing arbitrarily large arrays when using a SQL based database is heavily discouraged. To keep this same domain model and avoid storing variable size elements such as arrays, we would need to duplicate information about event or person.
3. Even when the association is constrained to a single direction, our multiplicities allow for an optional association. This might be desired behaviour (i.e. people should be able to exist in our application without an event and vice versa), but it allows for an optional association. This is not bad but it is not best practice. 

To remedy these problems, we introduce an association class called _registration_ \(R) which will be associated with both Person and Event. We will also constrain these associations by making them unidirectional and necessitating that one and only one instance of person and one and only one instance of event must be associated with a registration. Simply, a regitration can only hold information about one person and one event. In this way it mediates the relationship between people and the events they register for. 

image::BetterUML1.PNG[align="center"]

It may appear that registrations for events can still be duplicated (i.e. Someone can register for the same event tiwce). Addressing this concern depends on how databasing is implemented. For some implementations, the combination of a unique identifier for person and a unique identifier for event forms a unique identifier for registration. So, if a person tries to register for an event twice, the database will throw an error. In other implementations, this may not be the case as registration will be given a unique id. In this case preventing duplication is delegated to code. 

The final model can be found below and is generated by the following code:

image::DomainModel.PNG[]

[source,Umple]
----
class RegistrationManager
{
}

class Person
{
  name;
}

class Event
{
  name;
  Date eventDate;
  Time startTime;
  Time endTime;
}

class Registration
{
  Integer id;
  }

association {
    1 RegistrationManager registrationManager <@>- 0..* Registration registrations;
}

association {
    1 RegistrationManager registrationManager <@>- 0..* Event events;
}

association {
    1 RegistrationManager registrationManager <@>- 0..* Person persons;
}

association {
   0..* Registration registration ->  1 Event event ;
}


association {
    0..* Registration registration ->  1 Person person;
}
----

The addition of the overarching RegistrationManager is only necessary if there will be more than one instance of our application. This is not the case for this course so it is not necessary.

Finally, we generate Java code by clicking the *Generate Java* button. Although the Umple generated Java code can be used, but is too verbose and not JPA compliant. You can see this by comparing the generated Java code to the code found in link:https://github.com/McGill-ECSE321-Fall2023/EventRegistration/tree/main/src/main/java/ca/mcgill/ecse321/EventRegistration/models[Model Classes].

Each class in our domain model should have its own file. Create a new folder under _src>main>java_ called *model* and add the model files into that folder.
Make sure your model files declare the package:

[source,java]
----
package ca.mcgill.ecse321.eventregistration.model;
----

Your project folder structure should now look like this:

[source,none]
----
EventRegistration-Backend
├── build.gradle
├── settings.gradle
└── src
    ├── main
    │   ├── java
    │   │   └── ca\mcgill\ecse321\eventregistration
    │   │        ├── EventRegistrationApplication.java
    │   │        └── model
    │   │            ├── Event.java
    │   │            ├── Person.java
    │   │            ├── Registration.java
    │   │            └── RegistrationManager.java
    │   └── resources
    │       └── application.settings
    │
    └── test
        └── java
            └── ca\mcgill\ecse321\eventregistration
                └── EventRegistrationApplicationTests
----


==== JPA Annotations
This is an exercise in being able to write JPA compliant code simply by looking at the domain model, which is left up to the students. A brief explanation for relevant JPA tags is here provided:

* *@MappedSuperclass*: Placed above a class declaration to denote that all annotated attributes are inherited by any subclass, however the Superclass has no table in the database.
* *@Entity*: Placed before the class declaration to signify an entity that corresponds to a database table by the same name.
* *@Inheritance(strategy=Value)*: Used to specify the inheritance strategy for a class heirarchy, where the superclass is annotated with the _@Entity_ tag.
* *@Id*: Placed before the attribute declaration that will serve as the primary unique identifier for the class in the corresponding database table.
* *@GeneratedValue(strategy=Value)*: Placed between the _@Id_ tag and the attribute declaration, indicating the attribute is to be generated. Value must be a valid generation strategy (See note below).
* *@OnetoMany* or *@ManytoOne*: Placed before get method for attribute to signify the multiplicity in associative relationship between the current class and reference class. The first word is the multiplicity of the current class, with the other representing the multiplicity of the other calss. The _cascade_ property being set to _cascadeType.ALL_ ensures all operations of the defining class are persisted. The _optional_ property being set to false means the association the tag defines must exist. In this case, the defining class cannot exist without knowledge of the referenced class. 

A comprehesive list of JPA Annotations can be found link:https://dzone.com/articles/all-jpa-annotations-mapping-annotations[here]. Full documentation of JPA can be found link:https://javadoc.io/doc/jakarta.persistence/jakarta.persistence-api/latest/jakarta.persistence/jakarta/persistence/package-summary.html[here], under the *Annotation Type Summary* table. 